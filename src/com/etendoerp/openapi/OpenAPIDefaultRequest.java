package com.etendoerp.openapi;

import static org.apache.commons.lang3.BooleanUtils.isTrue;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.apache.log4j.Logger;
import org.openbravo.dal.core.OBContext;
import org.openbravo.dal.service.OBDal;

import com.etendoerp.openapi.data.OpenAPIRequest;
import com.etendoerp.openapi.data.OpenApiFlow;
import com.etendoerp.openapi.data.OpenApiFlowPoint;
import com.etendoerp.openapi.model.OpenAPIEndpoint;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.Operation;
import io.swagger.v3.oas.models.Paths;
import io.swagger.v3.oas.models.tags.Tag;

/**
 * Abstract class that adds OpenAPI documentation for the default endpoints. A default endpoint is an endpoint that is
 * not documented by another OpenAPIEndpoint implementation. This abstract class adds the endpoints to the "Default" tag
 * and to the tags of the flows where the endpoints are related.
 */
public abstract class OpenAPIDefaultRequest implements OpenAPIEndpoint {
  public static final String DEFAULT_TAG = "Default";

  /**
   * Returns the array of classes that this default request handler applies to.
   * <p>
   * Implementations should return the list of Java classes (usually controllers or request handlers)
   * whose requests are considered by this OpenAPIDefaultRequest. The class names are later
   * compared against {@link com.etendoerp.openapi.data.OpenAPIRequest#getClassname()} to decide
   * whether a flow point belongs to this handler.
   *
   * @return an array of Class objects that this handler applies to
   */
  protected abstract Class<?>[] getClasses();

  /**
   * Returns the endpoint path in the OpenAPI Paths object where operations will be added.
   * <p>
   * Implementations should return the relative path (for example, "/api/myendpoint") where
   * the GET/POST/PUT operations generated by this handler will be attached in the resulting
   * OpenAPI document.
   *
   * @return the endpoint path to use in the OpenAPI Paths map
   */
  protected abstract String getEndpointPath();

  private static final Logger log = Logger.getLogger(OpenAPIDefaultRequest.class);

  private ThreadLocal<String> requestedTag = new ThreadLocal<>();


  /**
   * Retrieves a list of OpenApiFlow objects.
   *
   * @return a list of OpenApiFlow objects.
   */
  private List<OpenApiFlow> getFlows() {
    return OBDal.getInstance().createCriteria(OpenApiFlow.class).list();
  }

  /**
   * Retrieves a list of tags, this tags are the tags where this class will add the endpoints. In general, this list is
   * a list of the flows where the endpoints added by this class are related. Addionally, a "generic" tag is added to
   * allow the user to see the endpoints of this class.
   *
   * @return a list of tags.
   */
  private List<String> getTags() {
    Set<String> tags = getFlows().stream().filter(this::flowHasDefaultRequests).map(OpenApiFlow::getName).collect(
        Collectors.toSet());
    tags.add(DEFAULT_TAG);
    return tags.stream().sorted().collect(Collectors.toList());
  }

  /**
   * Checks if the given OpenApiFlow has any default requests.
   * <p>
   * This method iterates over the list of OpenApiFlowPoint objects associated with the given OpenApiFlow,
   * retrieves the OpenAPIRequest for each flow point, and checks if any of the requests match the classes
   * defined in this class.
   *
   * @param flow
   *     the OpenApiFlow object to check for default requests
   * @return true if any of the OpenAPIRequest objects match the classes, false otherwise
   */
  private boolean flowHasDefaultRequests(OpenApiFlow flow) {
    return flow.getETAPIOpenApiFlowPointList().stream()
        .map(OpenApiFlowPoint::getEtapiOpenapiReq)
        .anyMatch(this::matchesClass);
  }

  /**
   * Checks if the given OpenAPIRequest matches any class in the list of classes.
   * <p>
   * This method iterates over the classes and checks if the class name matches the classname of the provided OpenAPIRequest.
   *
   * @param etapiOpenapiReq
   *     the OpenAPIRequest object to check
   * @return true if the classname of the OpenAPIRequest matches any class name, false otherwise
   */
  private boolean matchesClass(OpenAPIRequest etapiOpenapiReq) {
    return Arrays.stream(getClasses())
        .anyMatch(clazz -> StringUtils.equalsIgnoreCase(etapiOpenapiReq.getClassname(), clazz.getName()));
  }

  /**
   * Check if the requested tag, if any, is contained in the list of valid tags where this class can add endpoints.
   *
   * @param tag
   *     the tag to check.
   * @return true if the tag is valid, false otherwise.
   */
  @Override
  public boolean isValid(String tag) {
    try {
      OBContext.setAdminMode();
      if (tag == null) {
        return true;
      }
      if (getTags().contains(tag)) {
        requestedTag.set(tag);
        return true;
      }
      return false;
    } finally {
      OBContext.restorePreviousMode();
    }
  }

  /**
   * Adds OpenAPI documentation for the requested tags.
   *
   * @param openAPI
   *     the OpenAPI object to add documentation to.
   */
  @Override
  public void add(OpenAPI openAPI) {
    try {
      OBContext.setAdminMode();
      HashMap<String, String> descriptions = new HashMap<>();
      AtomicBoolean addedEndpoints = new AtomicBoolean(false);
      getFlows().forEach(flow -> {
        if (requestedTag.get() == null || StringUtils.equals(requestedTag.get(), flow.getName())) {
          processFlowEndpoints(openAPI, flow, descriptions, addedEndpoints);
          addFlowTag(openAPI, flow);
        }
      });
    } finally {
      requestedTag.remove();
      OBContext.restorePreviousMode();
    }
  }

  /**
   * Processes the endpoints of a given flow and adds them to the OpenAPI definition.
   * <p>
   * This method iterates through all endpoints in the flow, checks if they are of default type,
   * and adds their definitions to the OpenAPI object. It also tracks added endpoints and descriptions.
   *
   * @param openAPI
   *     the OpenAPI object to add definitions to
   * @param flow
   *     the OpenApiFlow containing the endpoints to process
   * @param descriptions
   *     a map to store endpoint descriptions
   * @param addedEndpoints
   *     a flag to track if any endpoints were added
   */
  private void processFlowEndpoints(OpenAPI openAPI, OpenApiFlow flow, HashMap<String, String> descriptions,
      AtomicBoolean addedEndpoints) {
    var endpoints = flow.getETAPIOpenApiFlowPointList();
    for (OpenApiFlowPoint endpoint : endpoints) {
      OpenAPIRequest etapiOpenapiReq = endpoint.getEtapiOpenapiReq();
      if (isDefaultType(etapiOpenapiReq)) {
        addedEndpoints.set(true);
        if (StringUtils.isNotEmpty(etapiOpenapiReq.getDescription())) {
          descriptions.put(etapiOpenapiReq.getName(), etapiOpenapiReq.getDescription());
        }
        addDefinition(openAPI, endpoint);
      }
    }
  }

  /**
   * Adds a tag for the given flow to the OpenAPI object.
   * <p>
   * This method creates a new tag with the flow's name and description and adds it to the
   * OpenAPI tags list. If the tags list doesn't exist, it creates one.
   *
   * @param openAPI
   *     the OpenAPI object to add the tag to
   * @param flow
   *     the OpenApiFlow to create a tag for
   */
  private void addFlowTag(OpenAPI openAPI, OpenApiFlow flow) {
    Tag tag = new Tag().name(flow.getName()).description(flow.getDescription());
    if (openAPI.getTags() == null) {
      openAPI.setTags(new ArrayList<>());
    }
    openAPI.getTags().add(tag);
  }

  /**
   * Checks if the given OpenAPIRequest is of type "DEF".
   * <p>
   * This method compares the type of the provided OpenAPIRequest with the string "DEF" using a case-insensitive comparison.
   *
   * @param etapiOpenapiReq
   *     the OpenAPIRequest object to check
   * @return true if the type of the OpenAPIRequest is "DEF", false otherwise
   */
  private static boolean isDefaultType(OpenAPIRequest etapiOpenapiReq) {
    return StringUtils.equalsIgnoreCase(etapiOpenapiReq.getType(), "DEF");
  }


  /**
   * Adds a definition to the OpenAPI object.
   *
   * @param openAPI
   *     the OpenAPI object to add the definition to.
   * @param endpoint
   */
  private void addDefinition(OpenAPI openAPI, OpenApiFlowPoint endpoint) {

    Paths paths = openAPI.getPaths();
    if (paths == null) {
      paths = new Paths();
      openAPI.setPaths(paths);
    }
    //check if path already exists
    if (paths.get(getEndpointPath()) == null) {
      paths.addPathItem(getEndpointPath(), new io.swagger.v3.oas.models.PathItem());
    }
    io.swagger.v3.oas.models.PathItem pathItem = paths.get(getEndpointPath());

    if (isTrue(endpoint.isPost())) {
      Operation postOp = getPOSTEndpoint(endpoint);
      pathItem.setPost(postOp);
    }
    if (isTrue(endpoint.isGet())) {
      Operation getOp = getGETEndpoint(endpoint);
      pathItem.setGet(getOp);
    }

    if (isTrue(endpoint.isPut())) {
      Operation putOp = getPUTEndpoint(endpoint);
      pathItem.setPut(putOp);
    }

  }

  /**
   * Builds an OpenAPI Operation for a GET request related to the provided flow point.
   * <p>
   * The default implementation returns null. Subclasses should override this method
   * to return a populated {@link io.swagger.v3.oas.models.Operation} describing the
   * GET operation for the given {@link OpenApiFlowPoint}.
   *
   * @param endpoint
   *     the flow point metadata used to build the Operation
   * @return a populated Operation instance for GET, or null if not implemented
   */
  public Operation getGETEndpoint(OpenApiFlowPoint endpoint) {
    log.debug("GET endpoint not implemented");
    return null;
  }

  /**
   * Builds an OpenAPI Operation for a POST request related to the provided flow point.
   * <p>
   * The default implementation returns null. Subclasses should override this method
   * to return a populated {@link io.swagger.v3.oas.models.Operation} describing the
   * POST operation for the given {@link OpenApiFlowPoint}.
   *
   * @param endpoint
   *     the flow point metadata used to build the Operation
   * @return a populated Operation instance for POST, or null if not implemented
   */
  public Operation getPOSTEndpoint(OpenApiFlowPoint endpoint) {
    log.debug("POST endpoint not implemented");

    return null;
  }


  /**
   * Builds an OpenAPI Operation for a PUT request related to the provided flow point.
   * <p>
   * The default implementation returns null. Subclasses should override this method
   * to return a populated {@link io.swagger.v3.oas.models.Operation} describing the
   * PUT operation for the given {@link OpenApiFlowPoint}.
   *
   * @param endpoint
   *     the flow point metadata used to build the Operation
   * @return a populated Operation instance for PUT, or null if not implemented
   */
  public Operation getPUTEndpoint(OpenApiFlowPoint endpoint) {
    log.debug("PUT endpoint not implemented");
    return null;

  }

}
